#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;

my $format;
my $regex = "\\t";
my $noheader;
my $help;

GetOptions('format=s' => \$format, 'regex=s' => \$regex, 'help|?' => \$help, 'noheader' => \$noheader)
  or die "error in command line arguments\n";

if ($help) {
  print <<EOF;
usage: md-table [opts] [file1 ...]

Outputs a markdown table by splitting each line of input from <>. The first
line is assumed to be the header. Any lines that do not split into the same
number of fields as the first line are ignored with a warning printed to
STDERR.

--regex REGEX     Change the regex to split the line on (default: \\t)

--format FORMAT   Specify the column alignment with this shorthand CSV:
                    - n: no alignment
                    - l: left align
                    - c: center align
                    - r: right align
                  The default is 'no alignment' for all columns. An example
                  is "--format l,r,c", which would align three columns with
                  left, right, and center (in that order).

--noheader        Do not use the first line as a header, instead output it as
                  the first row. Do not include a header in the output.
EOF
  exit;
}

sub row {
  s/^\s*(.*?)\s*$/$1/ foreach @_;
  return '| ' . join(' | ', @_) . ' |';
}

sub buildformat {
  my %h = (
    'n' => '---',
    'l' => ':---',
    'c' => ':---:',
    'r' => '---:',
  );

  return row map { $h{lc($_)} } @_;
}

sub main {
  $_ = <>;
  my @heads = split /$regex/i;
  if (not $format) {
    my @cols = ('n') x scalar(@heads);
    $format = buildformat @cols
  }
  else {
    my @formats = split ',', $format;
    if (@formats != @heads) {
      die 'mismatch between number of format fields ('.@formats.') and number of header fields ('.@heads.")\n";
    }
    $format = buildformat split /,/, $format;
  }

  local $\ = "\n";

  if ($noheader) {
    print $format;
    print row @heads;
  }
  else {
    print row @heads;
    print $format;
  }

  while ($_ = <>) {
    my @cells = split /$regex/i;
    if (@cells == @heads) {
      print row @cells;
    }
    else {
      warn "warn: ignoring line with wrong number of fields: $.: $_\n";
    }
  }
}

main
