#!/usr/bin/env python

# gridify text, see --help

import sys
import argparse
from tabulate import tabulate
import codecs
import operator

def parse_args():
    global args
    parser = argparse.ArgumentParser(description="""
Takes character-separated data in files or stdin and turns it into a grid,
just like mysql can do, using the tabulate[1] library.

Note: if --sepchar is a single space, multiple spaces will be collapsed into
a single space.

Examples:

    # chops all columns to 10 chars max, and only prints the 1st and 3rd column
    %(prog)s --truncate 10 --limit 0,2

    # examine input to determine useful options, this ignores all options
    # except for --format and --sepchar
    %(prog)s --examine

[1] https://bitbucket.org/astanin/python-tabulate
""", formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--limit', '-l',
        help='limit output to column indicies (0-based) (default: none)')
    parser.add_argument('--format', '-f', default='psql',
        help='format to use for printing, see tabulate\'s options (default: psql)')
    parser.add_argument('--truncate', '-t', metavar='N', default=0, type=int,
        help='truncate column content to N letters')
    parser.add_argument('--sepchar', '-s', default='\t',
        help='separating character between fields (default: \\t)')
    parser.add_argument('--field-count', '-c', metavar='N', type=int,
        help='only include lines from input with N fields')
    parser.add_argument('--examine', '-e', action='store_true',
        help='examine input for patterns (suppresses normal output, ignores most options')

    args, remaining = parser.parse_known_args()
    args.files = remaining
    args.limit = [int(x) for x in args.limit.split(',')] if args.limit else []

def get_lines(fh):
    for line in fh:
        fields = [v.strip() for v in line.rstrip().split(args.sepchar)]
        if args.sepchar == ' ':
            fields = [v for v in fields if len(v) > 0]
        if not args.examine:
            if args.field_count > 0 and args.field_count != len(fields):
                continue
            if len(args.limit):
                fields = [fields[i] for i in args.limit]
            if args.truncate > 0:
                fields = [v[:args.truncate] for v in fields]
        yield fields

def percentage(x, y):
#    return '%0.1f' % (100 * float(x)/float(y))
    return 100.0 * float(x)/float(y)

def read_file(fh):
    if args.examine:
        examine(fh)
    else:
        table = tabulate(get_lines(fh), tablefmt=args.format)
        print(table)

def read_files():
    if not args.files:
        read_file(sys.stdin)
    else:
        for f in args.files:
            if f == '-':
                read_file(sys.stdin)
            with codecs.open(f, 'r', 'utf-8') as fh:
                read_file(fh)

if __name__ == '__main__':
    parse_args()
    read_files()
