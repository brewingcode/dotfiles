#!/usr/bin/env node

const mdtable = require('../lib/dist/mdtable')
const fs = require('fs')

const argv = require('minimist')(process.argv.slice(2), {
  boolean: ['h', 'help'] 
})

const usage = `usage: mdtable [options and filename(s)]

Reads lines from stdin and/or filename(s) and outputs them in a nicely
formatted Markdown table.

-r REGEX     regex used to split each row into cells ("\t" by default)
-a ALIGN     string of "l", "r", and "c" to specify alignments for each cell
-n NAMES     CSV of header names (if first line of input is not headers)
-t N         number of characters to truncate each cell to
-i INDEXES   CSV of 1-based indexes to specify cells to include
-s N         number for being strict: only include lines that have N cells

Long args are also supported: --regex, --align, --names, --truncate,
--include/--indexes, and --strict. A filename of "-" will read from stdin.
`  

if (argv.help || argv.h) {
  console.log(usage)
  process.exit(0)
}

const regex = (argv.regex || argv.r) ? new RegExp(argv.regex||argv.r) : /\t/
const align = argv.align || argv.a
const names = argv.names || argv.n
const truncate = parseFloat(argv.truncate || argv.t)
const indexes = argv.indexes || argv.include || argv.i
const strict = parseFloat(argv.strict || argv.s)
let lines = []

function finish() {
  if (indexes) {
    const order = indexes.split(',').map(parseFloat)
    lines = lines.map(function(line) {
      const reordered = []
      for (const i of order) {
        reordered.push(line[i-1])
      }
      return reordered
    })
  }

  if (names) {
    lines.unshift(names.split(','))
  }

  console.log(mdtable(lines, {align}));
}

function add(str) {
  str.toString().split('\n').forEach(function(line) {
    const cells = line.split(regex)

    if (!isNaN(strict) && (cells.length !== strict)) {
      return
    }

    lines.push(cells.map(function(cell) {
      return isNaN(truncate) ? cell : cell.slice(0,truncate)
    }))
  })
}

argv._.forEach(function(arg) {
  if (arg === '-') { arg = '/dev/stdin' }
   add(fs.readFileSync(arg))
})

if (!process.stdin.isTTY || argv._.length === 0) {
  let stdin = ''
  process.stdin
    .on('data', function(chunk) { stdin += chunk })
    .on('end', function() {
      add(stdin)
      finish()
    })
}
else {
  finish()
}
