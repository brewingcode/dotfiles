
# Git shortcuts
alias gitcd='git rev-parse 2>/dev/null && cd "./$(git rev-parse --show-cdup)"'
alias gitrc='git rebase --continue'
alias gitra='git rebase --abort'

gitre() { git rebase -i "$(git merge-base HEAD "${1:-master}")"; }

# git-fixup-to-commit
gitfc() {
  ref="$1"
  shift
  ref=$(git rev-parse "$ref")
  if [ $# -eq 0 ]; then
    git commit --all --message='fixup! '"$ref"
  else
    git commit --message='fixup! '"$ref" -- "$@"
  fi
  git rebase -i "$ref"^
}

# git-fixup-to-previous
gitfp() {
  gitfc HEAD "$@"
}


gitup() {
  remote="${1:-origin}"
  git push --set-upstream "$remote" "$(git rev-parse --abbrev-ref HEAD)"
}

# GitHub URL for current repo.
gurl() {
  local remotename="${@:-origin}"
  local remote="$(git remote -v | awk '/^'"$remotename"'.*\(push\)$/ {print $2}')"
  [[ "$remote" ]] || return
  local user_repo="$(echo "$remote" | perl -pe 's/.*://;s/\.git$//')"
  echo "https://github.com/$user_repo"
}

# GitHub URL for current repo, including current branch + path.
alias gurlp='echo $(gurl)/tree/$(gbs)/$(git rev-parse --show-prefix)'

# OSX-specific Git shortcuts
if is_osx; then
  gt() {
    local path repo
    {
      pushd "${1:-$PWD}"
      path="$PWD"
      repo="$(git rev-parse --show-toplevel)"
      popd
    } >/dev/null 2>&1
    if [[ -e "$repo" ]]; then
      echo "Opening git repo $repo."
      gittower "$repo"
    else
      echo "Error: $path is not a git repo."
    fi
  }

  # open all changed files (that still actually exist) in the editor
  ged() {
    local files=()
    for f in $(git diff --name-only "$@"); do
      [[ -e "$f" ]] && files=("${files[@]}" "$f")
    done
    local n=${#files[@]}
    echo "Opening $n $([[ "$@" ]] || echo "modified ")file$([[ $n != 1 ]] && \
      echo s)${@:+ modified in }$@"
    atom "${files[@]}"
  }
fi

# print a nice view of all branch tips
#   githeads [remote_name]
# remote_name can be the bit after "refs/remotes/", or "." for the local repo, or
# blank to show all remotes plus the local repo
githeads() {
  if [[ "$1" == "" ]]; then
    git remote | while read -r remote; do
      githeads "$remote"
    done
    githeads "."
  else
    if [[ "$1" == "." ]]; then
      refspec=refs/heads
    else
      refspec=refs/remotes/$1
    fi

    echo "refspec: $refspec"
    git for-each-ref --sort=-committerdate \
      --format='%(committerdate)%09%(refname)%09%(objectname:short)%09%(committername)%09%(contents:subject)' \
      "$refspec" | perl -pe 's,refs/\S+/(\S+)\t,$1\t,' | gridify -t 50
  fi
}

# given the name of a git remote, fetch it and look for A..B rev ranges
# in the output so that we can print them nicely. If no remote is given,
# call `git remote` and run against each one.
gitsync() {
  if [[ "$1" == "" ]]; then
    git remote | while read -r remote; do
      echo "fetching $remote"
      gitsync "$remote"
    done
    git status
  else
    git fetch -p --tags $1 2>&1 \
      | perl -ne '
        next unless /\S/;
        print "# $_";
        if (/^\s+(\w{7,12}\.\.\w{7,12})\s/) {
          print "\n";
          $fmt = q/'\''%C(yellow)%h %Cred%ai%Creset %s%Cgreen%d%Creset --%Cblue%an %Creset%n%b'\''/;
          $log = `git log --graph --pretty=format:$fmt $1 2>&1`;
          $log =~ s/\s*$//s;
          print "$log\n\n" unless $log =~ /fatal: ambiguous argument/;
          print `git diff --stat $1`, "\n";
        }'
  fi
}

# see `gitsumm` function
gittail() {
  count="${1:-10}"
  if [ -n "$2" ]; then
    refs="remotes/$2"
  else
    refs="heads"
  fi

  git for-each-ref --sort=committerdate refs/"$refs" \
    --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))' \
    | tail -n "$count"
}

# summary of local and remote branches
gitsum() {
  git remote | sort | uniq | while read -r i; do
    giturl=$(git remote get-url $i 2>/dev/null)
    echo "# remote: $i $giturl"
    gittail "$1" "$i"
  done

  echo "# local: "
  gittail "$1"
}

# checkout master, pull it, and switch back
gitmast() {
  head="$(git rev-parse --abbrev-ref HEAD)"
  gitsync
  git checkout master && git pull && git checkout "$head"
}

# no whitespace
gitnw() {
  git diff -b --numstat \
    | egrep $'^0\t0\t' \
    | cut -d$'\t' -f3- \
    | xargs git checkout HEAD --
}

# print commit sha of the merge commit for when commit $1 was merged into
# branch $2 (master by default)
# https://stackoverflow.com/a/10079510/2926055
gitwhen() {
  [ -z "$1" ] && { echo "need a commit sha to search for" >&2; return 1; }
  tip="${2:-master}"
  tmp1=$(mktemp /tmp/gitwhen.XXXX)
  tmp2=$(mktemp /tmp/gitwhen.XXXX)
  git rev-list --ancestry-path "$1".."$tip" > "$tmp1"
  git rev-list --first-parent "$1".."$tip" > "$tmp2"
  perl -ne 'print if ($seen{$_} .= @ARGV) =~ /10$/' "$tmp1" "$tmp2" | tail -n 1
  rm "$tmp1" "$tmp2"
}

# get merge-base of $1 (other branch, default master) and $2 (this branch, default HEAD)
gitmb() {
  other="${1:-master}"
  this="${2:-HEAD}"
  git merge-base "$other" "$this"
}

# git-rebase-merge-base: rebase from the merge-base of us and master (or the
# given ref). seems like this should be some setting that's already in git
gitrb() {
  git rebase -i --autosquash "$(gitmb "$1")"
}

# git stash-pull-apply
gitspa() {
  git stash && git pull --rebase && git stash apply
}

# git stash-checkout-apply
gitsca() {
  git stash && git checkout "${1:-master}" && git stash apply
}
